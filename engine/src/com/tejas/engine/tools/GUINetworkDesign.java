/*******************************************************************************
 * Copyright (c) 2013-2014 Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v3
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 *
 * Contributors:
 *     Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza - initial API and implementation
 ******************************************************************************/

package com.tejas.engine.tools;

import com.tejas.engine.tools.IGUIModule;
import com.tejas.engine.utils.CellRenderers;
import com.tejas.engine.utils.ClassAwareTableModel;
import com.tejas.engine.utils.ClassLoaderUtils;
import com.tejas.engine.utils.DoubleUtils;
import com.tejas.engine.utils.FullScrollPaneLayout;
import com.tejas.engine.utils.IntUtils;
import com.tejas.engine.utils.Pair;
import com.tejas.engine.utils.PopupMenuNetPlan;
import com.tejas.engine.utils.ProportionalResizeJSplitPaneListener;
import com.tejas.engine.utils.StringUtils;
import com.tejas.engine.utils.TabIcon;
import com.tejas.engine.utils.ThreadExecutionController;
import com.tejas.engine.utils.Triple;
import com.tejas.engine.utils.WiderJComboBox;
import com.tejas.engine.interfaces.networkDesign.Configuration;
import com.tejas.engine.interfaces.networkDesign.IAlgorithm;
import com.tejas.engine.interfaces.networkDesign.IAlgorithmMultiLayer;
import com.tejas.engine.interfaces.networkDesign.IReport;
import com.tejas.engine.interfaces.networkDesign.Net2PlanException;
import com.tejas.engine.interfaces.networkDesign.NetPlan;

import static com.tejas.engine.tools.IGUIModule.CURRENT_DIR;

import com.tejas.engine.interfaces.networkDesign.*;
import com.tejas.engine.internal.ErrorHandling;
import com.tejas.engine.internal.IExternal;
import com.tejas.engine.internal.SystemUtils;
import com.tejas.engine.libraries.GraphTheoryMetrics;
import com.tejas.engine.libraries.GraphUtils;
import com.tejas.engine.libraries.NetworkPerformanceMetrics;
import com.tejas.engine.utils.*;
import com.tejas.engine.utils.AdvancedJTable.ColumnHeaderToolTips;
import com.tejas.engine.utils.CellRenderers.LinkUtilizationCellRenderer;
import com.tejas.engine.utils.CellRenderers.LostTrafficCellRenderer;
import com.tejas.engine.utils.CellRenderers.NumberCellRenderer;
import com.tejas.engine.utils.topology.INetworkCallback;
import com.tejas.engine.utils.topology.plugins.AddLinkGraphPlugin;
import com.tejas.engine.utils.topology.plugins.ITopologyCanvasPlugin;
import com.tejas.engine.utils.topology.plugins.JUNGCanvas;
import com.tejas.engine.utils.topology.plugins.MoveNodePlugin;
import com.tejas.engine.utils.topology.plugins.PanGraphPlugin;
import com.tejas.engine.utils.topology.plugins.PopupEditGraphPlugin;
import com.tejas.engine.utils.topology.plugins.TopologyPanel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Rectangle;
import java.awt.event.*;
import java.awt.geom.Point2D;
import java.io.Closeable;
import java.io.File;
import java.util.Map.Entry;
import java.util.*;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import net.miginfocom.swing.MigLayout;

/**
 * Targeted to evaluate the network designs generated by built-in or user-defined
 * static planning algorithms, deciding on aspects such as the network topology,
 * the traffic routing, link capacities, protection routes and so on. Algorithms
 * based on constrained optimization formulations (i.e. ILPs) can be fast-prototyped
 * using the open-source Java Optimization Modeler library, to interface
 * to a number of external solvers such as GPLK, CPLEX or IPOPT.
 *
 * @author Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza
 * @since 0.2.0
 */
public final class GUINetworkDesign extends IGUIModule implements INetworkCallback, ThreadExecutionController.IThreadExecutionHandler
{
    private static final long serialVersionUID = 1L;

    private final JTextArea txt_netPlanLog;
    private final ThreadExecutionController algorithmController, reportController;

    private final List<NetPlan> netPlans;
    private final TopologyPanel pan_topology;
    private final JPanel pan_param, pan_edit, pan_execution;
    private final JSplitPane pan_viewReports;
    private final JTabbedPane reportsPane, rightPanel, pan_editnetPlan;
    private final RunnableSelector algorithmSelector, reportSelector;
    private final JTable[] netPlanTables;
    private final JComboBox layerChooser;
    private final JPanel layerPane;
    private final JPanel leftPane;
    private final ParamValueTable[] networkSummaryTables;
    private List<FixedColumnDecorator> decorators;
    
    private JTextField networkName;
    private JTextArea networkDescription;
    
    @Override
    public List<NetPlan> getDesign()
    {
        if (netPlans.size() > 1)
        {
            Object[] options = {"Save all layers", "Save this layer", "Cancel"};
            int n = JOptionPane.showOptionDialog(null, "Multilayer design, what do you actually save?", "Save design", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
            if (n == JOptionPane.YES_OPTION) return netPlans;
            else if (n == JOptionPane.CANCEL_OPTION) return new LinkedList<NetPlan>();
        }
        
        List<NetPlan> aux = new LinkedList<NetPlan>();
        aux.add(getCurrentNetPlan().getSecond());
        
        return aux;
    }

    private long start;

    private final static String[][] netPlanTablesHeaderTips = new String[][]
    {
	{"Node identifier", "Node name", "xCoord", "yCoord", "Total traffic entering to the network from this node", "Total traffic leaving the network from this node", "Traffic entering the node, but not targeted to it", "Total traffic (E)", "SRGs including this node", "Node-specific attributes"},
	{"Link identifier", "Origin node", "Destination node", "Capacity (E)", "Carried traffic (E)", "Reserved for protection (E)", "Utilization", "Length (km)", "Number of routes traversing the link", "Indicates whether this link has the highest utilization", "SRGs including this link", "Link-specific attributes"},
	{"Demand identifier", "Ingress node", "Egress node", "Offered traffic by the demand", "Carried traffic by routes carrying traffic from the demand", "Percentage of lost traffic from the offered", "Indicates wheter the demand has more than one associated route carrying traffic", "Number of associated routes", "Demand-specific attributes"},
	{"Route identifier", "Demand", "Ingress node", "Egress node", "Demand offered traffic (E)", "Carried traffic (E)", "Sequence of links", "Sequence of nodes", "Total route length", "Indicates whether this routing traverses (one of the) the link(s) with highest utilization", "Candidate protection segments for this route", "Route-specific attributes"},
	{"Protection segment identifier", "Origin node", "Destination node", "Reserved bandwidth for the segment", "Sequence of links", "Sequence of nodes", "Length (km)", "Dedicated/Shared", "# Routes", "Attributes"},
        {"SRG identifier", "Mean time to fail", "Mean time to repair", "Nodes included into the shared-risk group", "Links included into the shared-risk group", "# Affected routes", "Attributes"},
	{"Attribute", "Value"}
    };

    protected final static String[][] netPlanTablesHeader = new String[][]
    {
	{"Id", "Name", "xCoord", "yCoord", "Ingress traffic (E)", "Egress traffic (E)", "Traversing traffic (E)", "Total traffic (E)", "SRGs", "Attributes"},
	{"Id", "Origin node", "Destination node", "Capacity (E)", "Carried traffic (E)", "Reserved for protection (E)", "Utilization", "Length (km)", "# Routes", "Is bottleneck?", "SRGs", "Attributes"},
	{"Id", "Ingress node", "Egress node", "Offered traffic (E)", "Carried traffic (E)", "% Lost traffic", "Bifurcated", "# Routes", "Attributes"},
	{"Id", "Demand", "Ingress node", "Egress node", "Demand offered traffic (E)", "Carried traffic (E)", "Sequence of links", "Sequence of nodes", "Length (km)", "Bottleneck utilization", "Backup segments", "Attributes"},
	{"Id", "Origin node", "Destination node", "Reserved bandwidth (E)", "Sequence of links", "Sequence of nodes", "Length (km)", "Dedicated/Shared", "# Routes", "Attributes"},
        {"Id", "MTTF (hours)", "MTTR (hours)", "Nodes", "Links", "# Affected routes", "Attributes"},
	{"Attribute", "Value"}
    };

    /**
     * Default constructor.
     * 
     * @since 0.2.0
     */
    public GUINetworkDesign()
    {
	super("OFFLINE NETWORK DESIGN");
        
        networkSummaryTables = new ParamValueTable[4];
        for(int i = 0; i < networkSummaryTables.length; i++)
            networkSummaryTables[i] = new ParamValueTable(new String[] {"Metric", "Value"});

        File ALGORITHMS_DIRECTORY = new File(CURRENT_DIR + SystemUtils.getDirectorySeparator() + "workspace");
        ALGORITHMS_DIRECTORY = ALGORITHMS_DIRECTORY.isDirectory() ? ALGORITHMS_DIRECTORY : CURRENT_DIR;

        Set<Class<? extends IExternal>> _classes = new HashSet<Class<? extends IExternal>>();
        _classes.add(IAlgorithm.class);
        _classes.add(IAlgorithmMultiLayer.class);

        algorithmSelector = new RunnableSelector("Algorithm", null, _classes, ALGORITHMS_DIRECTORY, new ParameterValueDescriptionPanel());

        algorithmController = new ThreadExecutionController(this);
        reportController = new ThreadExecutionController(this);

        File REPORTS_DIRECTORY = new File(CURRENT_DIR + SystemUtils.getDirectorySeparator() + "workspace");
        REPORTS_DIRECTORY = REPORTS_DIRECTORY.isDirectory() ? REPORTS_DIRECTORY : CURRENT_DIR;
        reportSelector = new RunnableSelector("Report", null, IReport.class, REPORTS_DIRECTORY, new ReportParameterPanel());

        netPlans = new LinkedList<NetPlan>();
        netPlans.add(new NetPlan());

        rightPanel = new JTabbedPane();

        List<ITopologyCanvasPlugin> plugins = new LinkedList<ITopologyCanvasPlugin>();

        ITopologyCanvasPlugin addLinkPlugin = new AddLinkGraphPlugin(this, MouseEvent.BUTTON1_MASK, MouseEvent.BUTTON1_MASK | MouseEvent.SHIFT_MASK);
        plugins.add(addLinkPlugin);

        ITopologyCanvasPlugin popupPlugin = new PopupEditGraphPlugin(this, MouseEvent.BUTTON3_MASK);
        plugins.add(popupPlugin);

        ITopologyCanvasPlugin moveNodePlugin = new MoveNodePlugin(this, MouseEvent.BUTTON1_MASK | MouseEvent.CTRL_MASK);
        plugins.add(moveNodePlugin);

	ITopologyCanvasPlugin panningPlugin = new PanGraphPlugin(this, MouseEvent.BUTTON1_MASK);
	plugins.add(panningPlugin);
        
        pan_topology = new TopologyPanel(this, JUNGCanvas.class, plugins);
        pan_param = new JPanel();
        pan_edit = new JPanel();

        pan_topology.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Network topology"));
        pan_param.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Parameters"));
        pan_edit.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Edit network structure"));

        // Initialize execution panel
        pan_execution = new JPanel(new MigLayout("fill, insets 0 0 0 0"));
        initExecutionPanel();

        // Initialize netPlan panel
        pan_editnetPlan = new JTabbedPane();
	netPlanTables = new JTable[netPlanTablesHeader.length];
        initNetPlanPanel();
        
//        for(int tableId = 0; tableId < netPlanTables.length; tableId++)
//            AdvancedJTable.setToolTipHeader(netPlanTables[tableId], netPlanTablesHeaderTips[tableId]);

        // Initialize reports panel
        pan_viewReports = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
	reportsPane = new JTabbedPane();
        initReportPanel();

        rightPanel.add("Edit network plan", pan_editnetPlan);
        rightPanel.add("Algorithm execution", pan_execution);
        rightPanel.add("View reports", pan_viewReports);


        txt_netPlanLog = new JTextArea();
//        txt_netPlanLog.setBackground(getBackground());
        txt_netPlanLog.setFont(new JLabel().getFont());
        
	JPanel pane = new JPanel(new MigLayout("fill, insets 0 0 0 0"));
	pane.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Warnings"));
        pane.add(new JScrollPane(txt_netPlanLog), "grow");

        JSplitPane splitPaneTopology = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPaneTopology.setTopComponent(pan_topology);
        splitPaneTopology.setBottomComponent(pane);

        splitPaneTopology.setResizeWeight(0.8);
        splitPaneTopology.addPropertyChangeListener(new ProportionalResizeJSplitPaneListener());
        splitPaneTopology.setBorder(new LineBorder(contentPane.getBackground()));

        layerChooser = new WiderJComboBox();
        layerPane = new JPanel(new BorderLayout());
        layerPane.add(new JLabel("Select layer: "), BorderLayout.WEST);
        layerPane.add(layerChooser, BorderLayout.CENTER);
        layerChooser.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                updateSelectBoxes();
                pan_topology.getCanvas().updateTopology(getCurrentNetPlan().getSecond());
                
                String networkName = getCurrentNetPlan().getSecond().getNetworkName();
                if (networkName.isEmpty()) networkName = "Untitled";
                pan_topology.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Network topology: " + networkName));
            }
        });

        leftPane = new JPanel(new BorderLayout());
        leftPane.add(splitPaneTopology, BorderLayout.CENTER);

        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        splitPane.setLeftComponent(leftPane);
        splitPane.setRightComponent(rightPanel);
        splitPane.setResizeWeight(0.5);
        splitPane.addPropertyChangeListener(new ProportionalResizeJSplitPaneListener());

        splitPane.setBorder(BorderFactory.createEmptyBorder());
        contentPane.add(splitPane, "grow");
        updateLayerChooser();
    }

    @Override
    public Object execute(ThreadExecutionController controller)
    {
	start = System.nanoTime();

	if (controller == algorithmController)
	{
	    final Triple<File, String, Class> algorithm = algorithmSelector.getRunnable();
	    final Map<String, String> algorithmParameters = algorithmSelector.getRunnableParameters();
	    final Map<String, String> net2planParameters = Configuration.getOptions();

	    String _className = algorithm.getThird().getName();
	    String out;

	    List<NetPlan> aux = new LinkedList<NetPlan>();

	    if (_className.equals(IAlgorithm.class.getName()))
	    {
		NetPlan netPlan = getCurrentNetPlan().getSecond().copy();
		IAlgorithm instance = ClassLoaderUtils.getInstance(algorithm.getFirst(), algorithm.getSecond(), IAlgorithm.class);
		out = instance.executeAlgorithm(netPlan, algorithmParameters, net2planParameters);
		try { ((Closeable) instance.getClass().getClassLoader()).close(); }
		catch(Throwable e) { }
		aux.add(netPlan);
	    }
	    else if (_className.equals(IAlgorithmMultiLayer.class.getName()))
	    {
		Iterator<NetPlan> it = netPlans.iterator();
		while(it.hasNext())
		    aux.add(it.next().copy());

		IAlgorithmMultiLayer instance = ClassLoaderUtils.getInstance(algorithm.getFirst(), algorithm.getSecond(), IAlgorithmMultiLayer.class);
		out = instance.executeAlgorithm(aux, algorithmParameters, net2planParameters);
		try { ((Closeable) instance.getClass().getClassLoader()).close(); }
		catch(Throwable e) { }
	    }
	    else
	    {
		throw new RuntimeException("Bad");
	    }

            netPlans.clear();
	    netPlans.addAll(aux);
            
	    return out;
	}
	else if (controller == reportController)
	{
	    Triple<File, String, Class> report = reportSelector.getRunnable();
	    Map<String, String> reportParameters = reportSelector.getRunnableParameters();
	    Map<String, String> net2planParameters = Configuration.getOptions();
	    IReport instance = ClassLoaderUtils.getInstance(report.getFirst(), report.getSecond(), IReport.class);
	    Pair<String, ? extends JPanel> aux = Pair.of(instance.getTitle(), new ReportBrowser(instance.executeReport(getCurrentNetPlan().getSecond().copy(), reportParameters, net2planParameters)));
	    try { ((Closeable) instance.getClass().getClassLoader()).close(); }
	    catch(Throwable e) { }

	    return aux;
	}
	else
	{
	    throw new RuntimeException("Bad");
	}
    }

    @Override
    public void executionFinished(ThreadExecutionController controller, Object out)
    {
	double execTime = (System.nanoTime() - start) / 1e9;

	if (controller == algorithmController)
	{
	    try
	    {
		updateLayerChooser();
		pan_topology.getCanvas().updateTopology(getCurrentNetPlan().getSecond());
		pan_topology.getCanvas().zoomAll();

		String outMessage = String.format("Algorithm executed successfully%nExecution time: %.3g s%nExit message: %s", execTime, out);
		JOptionPane.showMessageDialog(null, outMessage, "Solve design", JOptionPane.PLAIN_MESSAGE);
                pan_editnetPlan.setSelectedIndex(0);
                rightPanel.setSelectedIndex(0);
	    }
	    catch (Throwable ex)
	    {
		ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
		ErrorHandling.showErrorDialog("Error executing algorithm");
	    }
	}
	else if (controller == reportController)
	{
	    Pair<String, ? extends JPanel> aux = (Pair<String, ? extends JPanel>) out;
	    reportsPane.addTab(aux.getFirst(), new TabIcon(null, TabIcon.TIMES_SIGN), aux.getSecond());
	    reportsPane.setSelectedIndex(reportsPane.getTabCount() - 1);
	}
	else
	{
	    ErrorHandling.showErrorDialog("Bad");
	}
    }

    @Override
    public void executionFailed(ThreadExecutionController controller)
    {
	if (controller == algorithmController)
	    ErrorHandling.showErrorDialog("Error executing algorithm");
	else if (controller == reportController)
	    ErrorHandling.showErrorDialog("Error executing report");
	else
	    ErrorHandling.showErrorDialog("Bad");
    }

    @Override
    public void loadDesign(NetPlan netPlan)
    {
        if (netPlan.isEmpty())
            throw new Net2PlanException("Network design is empty");
        
        netPlans.clear();
        netPlans.add(netPlan);

        updateLayerChooser();
        pan_topology.getCanvas().updateTopology(getCurrentNetPlan().getSecond());
        pan_topology.getCanvas().zoomAll();

        String aux_networkName = getCurrentNetPlan().getSecond().getNetworkName();
        if (aux_networkName.isEmpty()) aux_networkName = "Untitled";
	pan_topology.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Network topology: " + aux_networkName));
        
        rightPanel.setSelectedIndex(0);
    }

    @Override
    public void loadTrafficDemands(NetPlan demands)
    {
        Pair<Integer, NetPlan> aux = getCurrentNetPlan();
        NetPlan netPlan = aux.getSecond();
        if (netPlan.getNumberOfNodes() == 0) throw new Net2PlanException("A physical topology is required prior to load a demand set");
        
        int D = demands.getNumberOfDemands();
        if (D == 0) throw new Net2PlanException("Selected file doesn't contain a demand set");

        if (netPlan.hasDemands())
        {
            int result = JOptionPane.showConfirmDialog(null, "Current network structure contains a demand set. Overwrite?", "Loading demand set", JOptionPane.YES_NO_OPTION);
            if (result != JOptionPane.YES_OPTION) return;
        }
        
        NetPlan aux_netPlan = netPlan.copy();
        try
        {
            netPlan.addDemandsFrom(demands);
            updateSelectBoxes();
        }
        catch (Exception ex)
        {
            netPlans.set(aux.getFirst(), aux_netPlan);
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void updateNetPlanView()
    {
        updateSelectBoxes();
    }

    private static class LayerItem
    {
	public int index;
	public NetPlan netPlan;

	public LayerItem(int index, NetPlan netPlan)
	{
	    this.index = index;
	    this.netPlan = netPlan;
	}

	@Override
	public String toString()
	{
	    String layerName = netPlan.getNetworkName();
	    return layerName == null || layerName.isEmpty() ? "Layer " + index : layerName;
	}
    }

    private void updateLayerChooser()
    {
	ActionListener[] al = layerChooser.getActionListeners();
	for(ActionListener a : al)
	    layerChooser.removeActionListener(a);

	layerChooser.removeAllItems();
	Iterator<NetPlan> it = netPlans.iterator();

	int index = 0;
	while(it.hasNext())
	    layerChooser.addItem(new LayerItem(index++, it.next()));

	for(ActionListener a : al)
	    layerChooser.addActionListener(a);

	layerChooser.setSelectedIndex(0);

	if (layerChooser.getItemCount() > 1)
            leftPane.add(layerPane, BorderLayout.NORTH);
	else
            leftPane.remove(layerPane);

	leftPane.revalidate();
    }

    @Override
    public Pair<Integer, NetPlan> getCurrentNetPlan()
    {
	LayerItem sel = (LayerItem) layerChooser.getSelectedItem();
	return Pair.of(sel.index, sel.netPlan);
    }
    
    protected static void updateNetworkState(NetPlan _netState, Map<String, String> _net2planParameters, JTable[] _netPlanTables, String[][] _netPlanTablesHeader, List<FixedColumnDecorator> _decorators, JTextField networkName, JTextArea networkDescription, ParamValueTable[] _networkSummaryTables, JTextArea _txt_netPlanLog)
    {
        int N = _netState.getNumberOfNodes();
        int E = _netState.getNumberOfLinks();
        int D = _netState.getNumberOfDemands();
        int R = _netState.getNumberOfRoutes();
        int S = _netState.getNumberOfProtectionSegments();
        int numSRGs = _netState.getNumberOfSRGs();
        Map<String, String> networkAttributes = _netState.getNetworkAttributes();

        for (int tableId = 0; tableId < _netPlanTables.length; tableId++)
        {
            _netPlanTables[tableId].setEnabled(false);
            ((DefaultTableModel) _netPlanTables[tableId].getModel()).setDataVector(new Object[1][_netPlanTablesHeader[tableId].length], _netPlanTablesHeader[tableId]);
        }

        if (_txt_netPlanLog != null)
        {
            String[] warnings = _netState.checkValidityAndWarnings(_net2planParameters, true, true);

            StringBuilder log = new StringBuilder();
            for (int i = 0; i < warnings.length; i++)
                log.append(String.format("%s%n", warnings[i]));

            _txt_netPlanLog.setText(log.toString());
        }

        Object[][] nodeData = new Object[N][_netPlanTablesHeader[0].length];
        Object[][] linkData = new Object[E][_netPlanTablesHeader[1].length];
        Object[][] demandData = new Object[D][_netPlanTablesHeader[2].length];
        Object[][] routeData = new Object[R][_netPlanTablesHeader[3].length];
        Object[][] segmentData = new Object[S][_netPlanTablesHeader[4].length];
        Object[][] srgData = new Object[numSRGs][_netPlanTablesHeader[5].length];
        Object[][] networkData = new Object[networkAttributes.size()][_netPlanTablesHeader[6].length];

        double PRECISIONFACTOR = Double.parseDouble(_net2planParameters.get("precisionFactor"));

        int[][] linkTable = _netState.getLinkTable();
        int[][] demandTable = _netState.getDemandTable();

        double[] u_e = _netState.getLinkCapacityInErlangsVector();
        double[] d_e = _netState.getLinkLengthInKmVector();
        double[] h_d = _netState.getDemandOfferedTrafficInErlangsVector();
        double[] x_p = _netState.getRouteCarriedTrafficInErlangsVector();

        // Auxiliary variables
        double[] y_e = _netState.getLinkCarriedTrafficInErlangsVector();
        double[] r_e = _netState.getLinkCapacityReservedForProtectionInErlangsVector();
        double[] rho_e = _netState.getLinkUtilizationVector();
        double[] r_d = _netState.getDemandCarriedTrafficInErlangsVector();
        double[] lostTraffic_d = new double[D];

        double[] ingressTrafficPerNode = _netState.getNodeIngressTrafficInErlangsVector();
        double[] egressTrafficPerNode = _netState.getNodeEgressTrafficInErlangsVector();
        double[] traversingTrafficPerNode = _netState.getNodeTraversingTrafficInErlangsVector();

        NetworkPerformanceMetrics metrics = new NetworkPerformanceMetrics(_netState, _net2planParameters);

        for (int demandId = 0; demandId < D; demandId++)
        {
            h_d[demandId] = DoubleUtils.isEqualWithinAbsoluteTolerance(h_d[demandId], 0, PRECISIONFACTOR) ? 0 : h_d[demandId];
            r_d[demandId] = DoubleUtils.isEqualWithinAbsoluteTolerance(r_d[demandId], 0, PRECISIONFACTOR) ? 0 : r_d[demandId];
            lostTraffic_d[demandId] = h_d[demandId] == 0 ? 0 : 100 * (1 - r_d[demandId] / h_d[demandId]);
            if (lostTraffic_d[demandId] < PRECISIONFACTOR) lostTraffic_d[demandId] = 0;
        }

        // Get node data and put in the corresponding table
        if (N > 0)
        {
            for (int nodeId = 0; nodeId < N; nodeId++)
            {
                int[] srgIds = _netState.getNodeSRGs(nodeId);
                
                nodeData[nodeId][0] = nodeId;
                nodeData[nodeId][1] = _netState.getNodeName(nodeId);
                nodeData[nodeId][2] = _netState.getNodeXYPosition(nodeId)[0];
                nodeData[nodeId][3] = _netState.getNodeXYPosition(nodeId)[1];
                nodeData[nodeId][4] = ingressTrafficPerNode[nodeId];
                nodeData[nodeId][5] = egressTrafficPerNode[nodeId];
                nodeData[nodeId][6] = traversingTrafficPerNode[nodeId];
                nodeData[nodeId][7] = ingressTrafficPerNode[nodeId] + egressTrafficPerNode[nodeId] + traversingTrafficPerNode[nodeId];
                nodeData[nodeId][8] = srgIds.length > 0 ? IntUtils.join(srgIds, ", ") : "none";
                nodeData[nodeId][9] = StringUtils.mapToString(_netState.getNodeSpecificAttributes(nodeId), "=", ", ");
            }

            _netPlanTables[0].setEnabled(true);
            ((DefaultTableModel) _netPlanTables[0].getModel()).setDataVector(nodeData, _netPlanTablesHeader[0]);
        }

        // Get link data and put in the corresponding table
        if (E > 0)
        {
            for (int linkId = 0; linkId < E; linkId++)
            {
                int[] srgIds = _netState.getLinkSRGs(linkId);
                
                int[] traversingRoutes = _netState.getLinkTraversingRoutes(linkId);
                linkData[linkId][0] = linkId;
                linkData[linkId][1] = linkTable[linkId][0];
                linkData[linkId][2] = linkTable[linkId][1];
                linkData[linkId][3] = u_e[linkId];
                linkData[linkId][4] = y_e[linkId];
                linkData[linkId][5] = r_e[linkId];
                linkData[linkId][6] = rho_e[linkId];
                linkData[linkId][7] = d_e[linkId];
                linkData[linkId][8] = traversingRoutes.length + (traversingRoutes.length > 0 ? " (" + IntUtils.join(traversingRoutes, ",")  + ")" : "");
                linkData[linkId][9] = metrics.isBottleneckLink(linkId);
                linkData[linkId][10] = srgIds.length > 0 ? IntUtils.join(srgIds, ", ") : "none";
                linkData[linkId][11] = StringUtils.mapToString(_netState.getLinkSpecificAttributes(linkId), "=", ", ");
            }

            _netPlanTables[1].setEnabled(true);
            ((DefaultTableModel) _netPlanTables[1].getModel()).setDataVector(linkData, _netPlanTablesHeader[1]);
            _netPlanTables[1].getColumnModel().getColumn(_netPlanTables[1].convertColumnIndexToView(6)).setCellRenderer(new LinkUtilizationCellRenderer(true));
        }

        if (D > 0)
        {
            int[] bifurcationDegree = metrics.getDemandBifurcationDegreeVector();
            for (int demandId = 0; demandId < D; demandId++)
            {
                int[] routeIds = _netState.getDemandRoutes(demandId);

                demandData[demandId][0] = demandId;
                demandData[demandId][1] = demandTable[demandId][0];
                demandData[demandId][2] = demandTable[demandId][1];
                demandData[demandId][3] = h_d[demandId];
                demandData[demandId][4] = r_d[demandId];
                demandData[demandId][5] = lostTraffic_d[demandId];
                demandData[demandId][6] = bifurcationDegree[demandId] > 1 ? String.format("Yes (%d)", bifurcationDegree[demandId]) : "No";
                demandData[demandId][7] = routeIds.length + (routeIds.length > 0 ? " (" + IntUtils.join(routeIds, ",")  + ")" : "");
                demandData[demandId][8] = StringUtils.mapToString(_netState.getDemandSpecificAttributes(demandId), "=", ", ");
            }

            _netPlanTables[2].setEnabled(true);
            ((DefaultTableModel) _netPlanTables[2].getModel()).setDataVector(demandData, netPlanTablesHeader[2]);
            _netPlanTables[2].getColumnModel().getColumn(_netPlanTables[2].convertColumnIndexToView(5)).setCellRenderer(new LostTrafficCellRenderer(3, true));
        }

        if (R > 0)
        {
            for (int routeId = 0; routeId < R; routeId++)
            {
                int demandId = _netState.getRouteDemand(routeId);

                int[] plannedSequenceOfLinks = _netState.getRouteSequenceOfLinks(routeId);
                int[] plannedSequenceOfNodes = _netState.getRouteSequenceOfNodes(routeId);

                double maxUtilization = DoubleUtils.maxValue(DoubleUtils.select(rho_e, plannedSequenceOfLinks));

                routeData[routeId][0] = routeId;
                routeData[routeId][1] = demandId;
                routeData[routeId][2] = demandTable[demandId][0];
                routeData[routeId][3] = demandTable[demandId][1];
                routeData[routeId][4] = h_d[demandId];
                routeData[routeId][5] = x_p[routeId];
                routeData[routeId][6] = IntUtils.join(plannedSequenceOfLinks, " => ");
                routeData[routeId][7] = IntUtils.join(plannedSequenceOfNodes, " => ");
                routeData[routeId][8] = _netState.getRouteLengthInKm(routeId);
                routeData[routeId][9] = maxUtilization;
                routeData[routeId][10] = IntUtils.join(_netState.getRouteBackupSegmentList(routeId), ", ");
                routeData[routeId][11] = StringUtils.mapToString(_netState.getRouteSpecificAttributes(routeId), "=", ", ");
            }

            _netPlanTables[3].setEnabled(true);
            ((DefaultTableModel) _netPlanTables[3].getModel()).setDataVector(routeData, netPlanTablesHeader[3]);
            _netPlanTables[3].getColumnModel().getColumn(_netPlanTables[3].convertColumnIndexToView(9)).setCellRenderer(new LinkUtilizationCellRenderer(true));
        }

        if (S > 0)
        {
            for (int segmentId = 0; segmentId < S; segmentId++)
            {
                int[] sequenceOfLinks = _netState.getProtectionSegmentSequenceOfLinks(segmentId);
                int[] sequenceOfNodes = _netState.getProtectionSegmentSequenceOfNodes(segmentId);
                int[] routeIds = _netState.getProtectionSegmentRoutes(segmentId);
                int numRoutes = routeIds.length;

                segmentData[segmentId][0] = segmentId;
                segmentData[segmentId][1] = _netState.getProtectionSegmentOriginNode(segmentId);
                segmentData[segmentId][2] = _netState.getProtectionSegmentDestinationNode(segmentId);
                segmentData[segmentId][3] = _netState.getProtectionSegmentReservedBandwidthInErlangs(segmentId);
                segmentData[segmentId][4] = IntUtils.join(sequenceOfLinks, " => ");
                segmentData[segmentId][5] = IntUtils.join(sequenceOfNodes, " => ");
                segmentData[segmentId][6] = _netState.getProtectionSegmentLengthInKm(segmentId);
                segmentData[segmentId][7] = numRoutes > 1 ? "Shared" : (numRoutes == 0 ? "Not used" : "Dedicated");
                segmentData[segmentId][8] = routeIds.length + (routeIds.length > 0 ? " (" + IntUtils.join(routeIds, ",")  + ")" : "");
                segmentData[segmentId][9] = StringUtils.mapToString(_netState.getProtectionSegmentSpecificAttributes(segmentId), "=", ", ");
            }

            _netPlanTables[4].setEnabled(true);
            ((DefaultTableModel) _netPlanTables[4].getModel()).setDataVector(segmentData, netPlanTablesHeader[4]);
        }

        if (numSRGs > 0)
        {
            for (int srgId = 0; srgId < numSRGs; srgId++)
            {
                int[] routeIds = _netState.getSRGRoutes(srgId);
                int numRoutes = routeIds.length;
                
                srgData[srgId][0] = srgId;
                srgData[srgId][1] = _netState.getSRGMeanTimeToFailInHours(srgId);
                srgData[srgId][2] = _netState.getSRGMeanTimeToRepairInHours(srgId);
                srgData[srgId][3] = IntUtils.join(_netState.getSRGNodes(srgId), ", ");
                srgData[srgId][4] = IntUtils.join(_netState.getSRGLinks(srgId), ", ");
                srgData[srgId][5] = numRoutes + (numRoutes > 0 ? " (" + IntUtils.join(routeIds, ",")  + ")" : "");
                srgData[srgId][6] = StringUtils.mapToString(_netState.getSRGSpecificAttributes(srgId), "=", ", ");
            }

            _netPlanTables[5].setEnabled(true);
            ((DefaultTableModel) _netPlanTables[5].getModel()).setDataVector(srgData, netPlanTablesHeader[5]);
        }

        int attribId = 0;
        for(Entry<String, String> entry : networkAttributes.entrySet())
        {
            networkData[attribId][0] = entry.getKey();
            networkData[attribId][1] = entry.getValue();
        }
        
        networkName.setText(_netState.getNetworkName());
        networkDescription.setText(_netState.getNetworkDescription());
	networkDescription.setCaretPosition(0);

        _netPlanTables[6].setEnabled(true);
        ((DefaultTableModel) _netPlanTables[6].getModel()).setDataVector(networkData, _netPlanTablesHeader[6]);

        for (FixedColumnDecorator decorator : _decorators)
        {
            List<JTable> list = new LinkedList<JTable>();
            list.add(decorator.getFixedTable());
            list.add(decorator.getMainTable());
            
            for(JTable table : list)
            {
                table.setDefaultRenderer(Boolean.class, new CellRenderers.CheckBoxRenderer(true));
                table.setDefaultRenderer(Double.class, new NumberCellRenderer(true));
                table.setDefaultRenderer(Object.class, new CellRenderers.NonEditableCellRenderer(true));
                table.setDefaultRenderer(Float.class, new NumberCellRenderer(true));
                table.setDefaultRenderer(Integer.class, new CellRenderers.NumberCellRenderer(true));
                table.setDefaultRenderer(String.class, new CellRenderers.NonEditableCellRenderer(true));
            }
        }

        double binaryRate = Double.parseDouble(_net2planParameters.get("binaryRateInBitsPerSecondPerErlang"));
        double erlangsToBpsFactor = Double.parseDouble(_net2planParameters.get("binaryRateInBitsPerSecondPerErlang"));

        double U_e = DoubleUtils.sum(u_e);
        double max_rho_e = U_e == 0 ? 0 : DoubleUtils.maxValue(rho_e);
        double max_rho_e_noProtection = U_e == 0 ? 0 : DoubleUtils.maxValue(DoubleUtils.divideNonSingular(y_e, _netState.getLinkCapacityNotReservedForProtectionInErlangsVector()));
        double u_e_avg = DoubleUtils.average(u_e);
        double[] l_e = _netState.getLinkLengthInKmVector();
        double H_d = DoubleUtils.sum(h_d);
        double R_d = DoubleUtils.sum(r_d);
        GraphTheoryMetrics metrics_hops = new GraphTheoryMetrics(linkTable, N, null);
        GraphTheoryMetrics metrics_km = new GraphTheoryMetrics(linkTable, N, l_e);
        GraphTheoryMetrics metrics_sec = new GraphTheoryMetrics(linkTable, N, _netState.getLinkPropagationDelayInSecondsVector());
        int[] nodeOutDegree = metrics_hops.getOutNodeDegree();
        int[] maxMinOutDegree = nodeOutDegree.length == 0 ? new int[] {0, 0} : IntUtils.maxMinValues(nodeOutDegree);
        double avgOutDegree = metrics_hops.getAverageOutNodeDegree();
        int networkDiameter_hops = (int) metrics_hops.getDiameter();
        double networkDiameter_km = metrics_km.getDiameter();
        double networkDiameter_ms = 1000 * metrics_sec.getDiameter();
        double offeredTrafficInErlangsPerNodePair = metrics.getNodePairAverageOfferedTrafficInErlangs();

        boolean isRoutingBifurcated = metrics.isRoutingBifurcated();

        double averageRouteLength_hops = 0;
        double averageRouteLength_km = 0;
        double averageRouteLength_ms = 0;

        if (R > 0 && R_d > 0)
        {
            averageRouteLength_hops = metrics.getRouteAverageLength(null);
            averageRouteLength_km = metrics.getRouteAverageLength(_netState.getLinkLengthInKmVector());
            averageRouteLength_ms = 1000 * metrics.getRouteAverageLength(_netState.getLinkPropagationDelayInSecondsVector());
        }

        double[] u_e_reservedForProtection = _netState.getLinkCapacityReservedForProtectionInErlangsVector();
        double U_e_reservedForProtection = DoubleUtils.sum(u_e_reservedForProtection);
        double u_e_reservedForProtection_avg = E == 0 ? 0 : U_e_reservedForProtection / E;
        double percentageReserved = U_e == 0 ? 0 : 100 * U_e_reservedForProtection / U_e;
        
        double blockedTraffic = metrics.getBlockedTrafficPercentage();
        double[] protectionDegree = metrics.getTrafficProtectionDegree();
        double percentageUnprotected = protectionDegree[0];
        double percentageDedicated = protectionDegree[1];
        double percentageShared = protectionDegree[2];
        
        String srgModel = metrics.getSRGModel();
        
        double[] aux_srgDisjointness = metrics.getSRGDisjointnessPercentage();
        double percentageRouteSRGDisjointness_withEndNodes = aux_srgDisjointness[0];
        double percentageRouteSRGDisjointness_withoutEndNodes = aux_srgDisjointness[1];

        Map<String, Object> topologyData = new LinkedHashMap<String, Object>();
        topologyData.put("Number of nodes", N);
        topologyData.put("Number of links", E);
        topologyData.put("Node out-degree (max, min, avg)", String.format("%d, %d, %.3f", maxMinOutDegree[0], maxMinOutDegree[1], avgOutDegree));
        topologyData.put("All links are bidirectional (yes/no)", GraphUtils.isBidirectional(_netState) ? "Yes" : "No");
        topologyData.put("Network diameter (hops, km, ms)", String.format("%d, %.3f, %.3g", networkDiameter_hops, networkDiameter_km, networkDiameter_ms));
        topologyData.put("Capacity installed: total (Erlangs, bps)", String.format("%.3f, %.3g", U_e, U_e * erlangsToBpsFactor));
        topologyData.put("Capacity installed: average per link (Erlangs, bps)", String.format("%.3f, %.3g", u_e_avg, u_e_avg * erlangsToBpsFactor));
        _networkSummaryTables[0].setData(topologyData);
        
        _networkSummaryTables[0].setToolTipText(0, 0, "Indicates the number of defined nodes");
        _networkSummaryTables[0].setToolTipText(1, 0, "Indicates the number of defined links");
        _networkSummaryTables[0].setToolTipText(2, 0, "Indicates the maximum/minimum/average value for the out-degree, that is, the number of outgoing links per node");
        _networkSummaryTables[0].setToolTipText(3, 0, "Indicates whether all links are bidirectional, that is, if there are the same number of links between each node pair in both directions (irrespective of the respective capacities)");
        _networkSummaryTables[0].setToolTipText(4, 0, "Indicates the network diameter, that is, the length of the largest shortest-path");
        _networkSummaryTables[0].setToolTipText(5, 0, "Indicates the total capacity installed in the network");
        _networkSummaryTables[0].setToolTipText(6, 0, "Indicates the average capacity installed per link");

        boolean isTrafficSymmetric = GraphUtils.isWeightedBidirectional(demandTable, h_d, N);

        Map<String, Object> trafficData = new LinkedHashMap<String, Object>();
        trafficData.put("Number of demands", D);
        trafficData.put("Offered traffic: total (Erlangs, bps)", String.format("%.3f, %.3g", H_d, H_d * erlangsToBpsFactor));
        trafficData.put("Offered traffic: average per node pair (Erlangs, bps)", String.format("%.3f, %.3g", offeredTrafficInErlangsPerNodePair, offeredTrafficInErlangsPerNodePair * erlangsToBpsFactor));
        trafficData.put("Blocked traffic (%)", String.format("%.3f", blockedTraffic));
        trafficData.put("Symmetric offered traffic?", isTrafficSymmetric ? "Yes" : "No");
        _networkSummaryTables[1].setData(trafficData);

        _networkSummaryTables[1].setToolTipText(0, 0, "Indicates the number of defined demands");
        _networkSummaryTables[1].setToolTipText(1, 0, "Indicates the total offered traffic to the network");
        _networkSummaryTables[1].setToolTipText(2, 0, "Indicates the total offered traffic to the network per each node pair");
        _networkSummaryTables[1].setToolTipText(3, 0, "Indicates the percentage of blocked traffic from the total offered to the network");
        _networkSummaryTables[1].setToolTipText(4, 0, "Indicates whether the offered traffic is symmetric, that is, if there are the same number of demands with the same offered traffic between each node pair in both directions");
        
        boolean hasRoutingLoops = GraphUtils.hasRoutingLoops(_netState, GraphUtils.CheckRoutingCycleType.NO_REPEAT_NODE);

        Map<String, Object> routingData = new LinkedHashMap<String, Object>();
        routingData.put("Number of routes", R);
        routingData.put("Bifurcated routing (yes/no)", isRoutingBifurcated ? "Yes" : "No");
        routingData.put("Network congestion - bottleneck utilization % (w. reserved bw, w.o. reserved bw)", String.format("%.3f, %.3f", max_rho_e, max_rho_e_noProtection));
        routingData.put("Average route length (hops, km, ms)", String.format("%.3f, %.3f, %.3g", averageRouteLength_hops, averageRouteLength_km, averageRouteLength_ms));
        routingData.put("Routing has loops?", hasRoutingLoops ? "Yes" : "No");
        
        _networkSummaryTables[2].setData(routingData);

        _networkSummaryTables[2].setToolTipText(0, 0, "Indicates the number of defined routes");
        _networkSummaryTables[2].setToolTipText(1, 0, "Indicates whether the routing is bifurcated, that is, if at least there are more than one route carrying traffic from any demand");
        _networkSummaryTables[2].setToolTipText(2, 0, "Indicates the network congestion, that is, the utilization of the busiest link");
        _networkSummaryTables[2].setToolTipText(3, 0, "Indicates the average route length");
        _networkSummaryTables[2].setToolTipText(4, 0, "Indicates whether the routing has loops, that is, if at least a route visits a node more than once");

        Map<String, Object> protectionData = new LinkedHashMap<String, Object>();
        protectionData.put("Number of protection segments", S);
        protectionData.put("Average link capacity reserved for protection (%, Erlangs, bps)", String.format("%.3f, %.3f, %.3g", percentageReserved, u_e_reservedForProtection_avg, u_e_reservedForProtection_avg * binaryRate));
        protectionData.put("% of carried traffic unprotected", String.format("%.3f", percentageUnprotected));
        protectionData.put("% of carried traffic complete and dedicated protection", String.format("%.3f", percentageDedicated));
        protectionData.put("% of carried traffic partial and/or shared protection", String.format("%.3f", percentageShared));
        protectionData.put("Number of SRGs", numSRGs);
        protectionData.put("SRG definition characteristic", srgModel);
        protectionData.put("% routes protected with SRG disjoint segments (w. end nodes, w.o. end nodes)", String.format("%.3f, %.3f", percentageRouteSRGDisjointness_withEndNodes, percentageRouteSRGDisjointness_withoutEndNodes));
        _networkSummaryTables[3].setData(protectionData);
        
        _networkSummaryTables[3].setToolTipText(0, 0, "Indicates the number of defined protection segments");
        _networkSummaryTables[3].setToolTipText(1, 0, "Indicates the average reserved bandwidth per protection segment");
        _networkSummaryTables[3].setToolTipText(2, 0, "Indicates the percentage of traffic (from the total) which is not protected by any segment");
        _networkSummaryTables[3].setToolTipText(3, 0, "Indicates the percentage of traffic (from the total) which is protected by dedicated segments reservating the total traffic of their corresponding routes");
        _networkSummaryTables[3].setToolTipText(4, 0, "Indicates the percentage of traffic (from the total) which is neither unprotected or dedicated");
        _networkSummaryTables[3].setToolTipText(5, 0, "Indicates the number of defined SRGs");
        _networkSummaryTables[3].setToolTipText(6, 0, "Indicates whether SRG definition follows one of the predefined models (per node, per link...), or 'Mixed' otherwise (or 'None' if no SRGs are defined)");
        _networkSummaryTables[3].setToolTipText(7, 0, "Indicates the percentage of routes from the total which have all protection segments SRG-disjoint, without taking into account the carried traffic per route");
        
        for(JTable table : _networkSummaryTables)
        {
            AdvancedJTable.setVisibleRowCount(table, table.getRowCount());
            AdvancedJTable.setWidthAsPercentages(table, 0.7, 0.3);
        }
    }

    private void updateSelectBoxes()
    {
        NetPlan netPlan = getCurrentNetPlan().getSecond();
        Map<String, String> net2planParameters = Configuration.getOptions();
        
        updateNetworkState(netPlan, net2planParameters, netPlanTables, netPlanTablesHeader, decorators, networkName, networkDescription, networkSummaryTables, txt_netPlanLog);
    }

    @Override
    public void moveNode(int nodeId, Point2D pos)
    {
	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan aux_netPlan = aux.getSecond().copy();
	aux.getSecond().setNodeXYPosition(nodeId, pos.getX(), pos.getY());
	try
	{
	    updateSelectBoxes();
	}
	catch (Exception ex)
	{
	    netPlans.set(aux.getFirst(), aux_netPlan);
	    ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
	    ErrorHandling.showErrorDialog("Unable to move node");
	}
    }

    @Override
    public void addNode(Point2D pos)
    {
	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan netPlan = aux.getSecond();
	NetPlan aux_netPlan = netPlan.copy();

	int N = netPlan.getNumberOfNodes();
	try
	{
	    netPlan.addNode(pos.getX(), pos.getY(), "Node " + N, new HashMap<String, String>());
	    updateSelectBoxes();
	    pan_topology.getCanvas().addNode(pos, null);
	    pan_topology.getCanvas().refresh();
	}
	catch (Exception ex)
	{
	    netPlans.set(aux.getFirst(), aux_netPlan);
	    ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
	    ErrorHandling.showErrorDialog("Unable to add node");
	}
    }

    @Override
    public void removeNode(int nodeId)
    {
	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan netPlan = aux.getSecond();
	NetPlan aux_netPlan = netPlan.copy();

	try
	{
	    netPlan.removeNode(nodeId);
	    updateSelectBoxes();
	    pan_topology.getCanvas().removeNode(nodeId);
	    pan_topology.getCanvas().refresh();
	}
	catch (Exception ex)
	{
	    netPlans.set(aux.getFirst(), aux_netPlan);
	    ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
	    ErrorHandling.showErrorDialog("Unable to remove node");
	}
    }

    @Override
    public void removeLink(int linkId)
    {
	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan netPlan = aux.getSecond();
	NetPlan aux_netPlan = netPlan.copy();

	try
	{
	    netPlan.removeLink(linkId);
	    updateSelectBoxes();
	    pan_topology.getCanvas().removeLink(linkId);
	    pan_topology.getCanvas().refresh();
	}
	catch (Exception ex)
	{
	    netPlans.set(aux.getFirst(), aux_netPlan);
	    ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
	    ErrorHandling.showErrorDialog("Unable to remove link");
	}
    }

    @Override
    public void addLink(int originNodeId, int destinationNodeId)
    {
	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan netPlan = aux.getSecond();
	NetPlan aux_netPlan = netPlan.copy();

	try
	{
	    netPlan.addLink(originNodeId, destinationNodeId, 0, 0, null);
	    updateSelectBoxes();
	    pan_topology.getCanvas().addLink(originNodeId, destinationNodeId);
	    pan_topology.getCanvas().refresh();
	}
	catch (Throwable ex)
	{
	    netPlans.set(aux.getFirst(), aux_netPlan);
	    ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
	    ErrorHandling.showErrorDialog("Unable to add link");
	}
    }

    @Override
    public void showNode(int nodeId)
    {
	int row = netPlanTables[0].convertRowIndexToView(nodeId);

	rightPanel.setSelectedIndex(0);
	pan_editnetPlan.setSelectedIndex(1);
	netPlanTables[0].getSelectionModel().setSelectionInterval(row, row);
	for (JTable table : netPlanTables)
	    if (!table.equals(netPlanTables[0]))
		table.getSelectionModel().clearSelection();

	pan_topology.getCanvas().showNode(nodeId);
	pan_topology.getCanvas().refresh();
    }

    /**
     *
     * @param demandId
     */
    @Override
    public void showDemand(int demandId)
    {
	int row = netPlanTables[2].convertRowIndexToView(demandId);

	rightPanel.setSelectedIndex(0);
	pan_editnetPlan.setSelectedIndex(3);
	netPlanTables[2].getSelectionModel().setSelectionInterval(row, row);
	for (JTable table : netPlanTables)
	{
	    if (!table.equals(netPlanTables[2]))
	    {
		table.getSelectionModel().clearSelection();
	    }
	}

	NetPlan netPlan = getCurrentNetPlan().getSecond();

	pan_topology.getCanvas().showNodes(new int[]
		{
		    netPlan.getDemandIngressNode(demandId), netPlan.getDemandEgressNode(demandId)
		});
	pan_topology.getCanvas().refresh();
    }

    /**
     *
     * @param segmentId
     */
    @Override
    public void showSegment(int segmentId)
    {
	int row = netPlanTables[4].convertRowIndexToView(segmentId);

	rightPanel.setSelectedIndex(0);
	pan_editnetPlan.setSelectedIndex(5);
	netPlanTables[4].getSelectionModel().setSelectionInterval(row, row);
	for (JTable table : netPlanTables)
	{
	    if (!table.equals(netPlanTables[4]))
	    {
		table.getSelectionModel().clearSelection();
	    }
	}

	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan netPlan = aux.getSecond();
	pan_topology.getCanvas().showRoute(netPlan.getProtectionSegmentSequenceOfLinks(segmentId));
	pan_topology.getCanvas().refresh();
    }

    @Override
    public void showSRG(int srgId)
    {
	int row = netPlanTables[5].convertRowIndexToView(srgId);

	rightPanel.setSelectedIndex(0);
	pan_editnetPlan.setSelectedIndex(6);
	netPlanTables[5].getSelectionModel().setSelectionInterval(row, row);
	for (JTable table : netPlanTables)
	    if (!table.equals(netPlanTables[5]))
    		table.getSelectionModel().clearSelection();

	Pair<Integer, NetPlan> aux = getCurrentNetPlan();
	NetPlan netPlan = aux.getSecond();
        
        int[] nodeIds = netPlan.getSRGNodes(srgId);
        int[] linkIds = netPlan.getSRGLinks(srgId);
	pan_topology.getCanvas().showNodesAndLinks(nodeIds, linkIds);
	pan_topology.getCanvas().refresh();
    }

    @Override
    public void showRoute(int routeId)
    {
	int row = netPlanTables[3].convertRowIndexToView(routeId);

	rightPanel.setSelectedIndex(0);
	pan_editnetPlan.setSelectedIndex(4);
	netPlanTables[3].getSelectionModel().setSelectionInterval(row, row);
	for (JTable table : netPlanTables)
	{
	    if (!table.equals(netPlanTables[3]))
	    {
		table.getSelectionModel().clearSelection();
	    }
	}

	NetPlan netPlan = getCurrentNetPlan().getSecond();
	pan_topology.getCanvas().showRoute(netPlan.getRouteSequenceOfLinks(routeId));
	pan_topology.getCanvas().refresh();
    }

    @Override
    public void showLink(int linkId)
    {
	int row = netPlanTables[1].convertRowIndexToView(linkId);

	rightPanel.setSelectedIndex(0);
	pan_editnetPlan.setSelectedIndex(2);
	netPlanTables[1].getSelectionModel().setSelectionInterval(row, row);
	for (JTable table : netPlanTables)
	{
	    if (!table.equals(netPlanTables[1]))
	    {
		table.getSelectionModel().clearSelection();
	    }
	}

	pan_topology.getCanvas().showLink(linkId);
	pan_topology.getCanvas().refresh();
    }
    
    private void initExecutionPanel()
    {
	JPanel pnl_buttons = new JPanel(new MigLayout("", "[center, grow]", "[]"));

	JButton btn_solve = new JButton("Execute");
	pnl_buttons.add(btn_solve);
	btn_solve.addActionListener(new ActionListener()
	{
	    @Override
	    public void actionPerformed(ActionEvent e)
	    {
		algorithmController.execute();
	    }
	});

//	JButton btn_reset = new JButton("Reset");
//	pnl_buttons.add(btn_reset);
//	btn_reset.addActionListener(new ActionListener()
//	{
//
//	    @Override
//	    public void actionPerformed(ActionEvent e)
//	    {
//                reset();
//	    }
//	});

//	algorithmSelector.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Algorithm execution"));

	pan_execution.setLayout(new MigLayout("insets 0 0 0 0", "[grow]", "[grow]"));
	pan_execution.add(algorithmSelector, "grow");
	pan_execution.add(pnl_buttons, "dock south");
    }
    
    @Override
    public void reset()
    {
        try
        {
            boolean reset = askForReset();
            if (!reset) return;

            algorithmSelector.reset();
            reportSelector.reset();
            reportsPane.removeAll();
            netPlans.clear();
            netPlans.add(new NetPlan());
            updateLayerChooser();
            updateSelectBoxes();
            pan_topology.getCanvas().reset();
        }
        catch (Exception ex)
        {
            ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
            ErrorHandling.showErrorDialog("Unable to reset");
        }
    }
    
    protected static void initializeNetworkState(final INetworkCallback callback, final TopologyPanel topologyPanel, JTabbedPane _networkStatePane, final List<NetPlan> _netPlans, JTable[] _netPlanTables, DefaultTableModel[] _model, List<FixedColumnDecorator> _decorators, String[][] _netPlanTablesHeader, JTextField _networkName, JTextArea _networkDescription, ParamValueTable[] _networkSummaryTables, boolean isEditable)
    {
	JScrollPane[] scrollPane = new JScrollPane[_netPlanTables.length];
	ScrollPaneLayout[] scrollPaneLayout = new ScrollPaneLayout[_netPlanTables.length];

	KeyListener cursorNavigation = new TableCursorNavigation();

	for (int itemId = 0; itemId < _netPlanTables.length; itemId++)
	{
	    _netPlanTables[itemId].setAutoCreateRowSorter(true);

	    scrollPane[itemId] = new JScrollPane(_netPlanTables[itemId]);
	    scrollPaneLayout[itemId] = new FullScrollPaneLayout();
	    scrollPane[itemId].setLayout(scrollPaneLayout[itemId]);
	    scrollPane[itemId].setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
	    _netPlanTables[itemId].addKeyListener(cursorNavigation);

	    if (itemId < _netPlanTables.length - 1)
	    {
//		TableRowFilterSupport.forTable(netPlanTables[itemId]).apply();
		_decorators.add(new FixedColumnDecorator(1, scrollPane[itemId]));
		_decorators.get(itemId).getFixedTable().addKeyListener(cursorNavigation);
	    }
	}

        MouseAdapter nodeTableAdapter = new PopupMenuNetPlan(callback, topologyPanel, _netPlans, _netPlanTables[0], "node", isEditable);
	_netPlanTables[0].addMouseListener(nodeTableAdapter);
	_decorators.get(0).getFixedTable().addMouseListener(nodeTableAdapter);

        MouseAdapter linkTableAdapter = new PopupMenuNetPlan(callback, topologyPanel, _netPlans, _netPlanTables[1], "link", isEditable);
	_netPlanTables[1].addMouseListener(linkTableAdapter);
	_decorators.get(1).getFixedTable().addMouseListener(linkTableAdapter);

        MouseAdapter demandTableAdapter = new PopupMenuNetPlan(callback, topologyPanel, _netPlans, _netPlanTables[2], "demand", isEditable);
	_netPlanTables[2].addMouseListener(demandTableAdapter);
	_decorators.get(2).getFixedTable().addMouseListener(demandTableAdapter);

        MouseAdapter routeTableAdapter = new PopupMenuNetPlan(callback, topologyPanel, _netPlans, _netPlanTables[3], "route", isEditable);
	_netPlanTables[3].addMouseListener(routeTableAdapter);
	_decorators.get(3).getFixedTable().addMouseListener(routeTableAdapter);

        MouseAdapter segmentTableAdapter = new PopupMenuNetPlan(callback, topologyPanel, _netPlans, _netPlanTables[4], "protection segment", isEditable);
	_netPlanTables[4].addMouseListener(segmentTableAdapter);
	_decorators.get(4).getFixedTable().addMouseListener(segmentTableAdapter);
        
        MouseAdapter srgTableAdapter = new PopupMenuNetPlan(callback, topologyPanel, _netPlans, _netPlanTables[5], "SRG", isEditable);
	_netPlanTables[5].addMouseListener(srgTableAdapter);
	_decorators.get(5).getFixedTable().addMouseListener(srgTableAdapter);

	if (isEditable)
        {
            MouseAdapter networkTableAdapter = new MouseAdapter()
            {
                @Override
                public void mouseClicked(MouseEvent e)
                {
                    if (SwingUtilities.isRightMouseButton(e))
                    {
                        JPopupMenu popup = new JPopupMenu();

                        JMenuItem addAttribute = new JMenuItem("Add/edit attribute");
                        addAttribute.addActionListener(new ActionListener()
                        {

                            @Override
                            public void actionPerformed(ActionEvent e)
                            {
                                JTextField txt_key = new JTextField(20);
                                JTextField txt_value = new JTextField(20);

                                JPanel pane = new JPanel();
                                pane.add(new JLabel("Attribute: "));
                                pane.add(txt_key);
                                pane.add(Box.createHorizontalStrut(15));
                                pane.add(new JLabel("Value: "));
                                pane.add(txt_value);

                                Pair<Integer, NetPlan> aux = callback.getCurrentNetPlan();
                                NetPlan netPlan = aux.getSecond();
                                NetPlan aux_netPlan = netPlan.copy();

                                while (true)
                                {
                                    int result = JOptionPane.showConfirmDialog(null, pane, "Please enter an attribute name and its value", JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE);
                                    if (result != JOptionPane.OK_OPTION) return;

                                    try
                                    {
                                        if (txt_key.getText().isEmpty())
                                        {
                                            throw new Exception("Please, insert an attribute name");
                                        }
                                        netPlan.setNetworkAttribute(txt_key.getText(), txt_value.getText());
                                        break;
                                    }
                                    catch (Exception ex)
                                    {
                                        ErrorHandling.showErrorDialog(ex.getMessage(), "Error adding/editing attribute");
                                    }
                                }

                                try
                                {
                                    callback.updateNetPlanView();
                                }
                                catch (Exception ex)
                                {
                                    ErrorHandling.showErrorDialog(ex.getMessage(), "Unable to add attribute");
                                    _netPlans.set(aux.getFirst(), aux_netPlan);
                                }
                            }
                        });

                        popup.add(addAttribute);

                        JMenuItem removeAttribute = new JMenuItem("Remove attribute");

                        removeAttribute.addActionListener(new ActionListener()
                        {

                            @Override
                            public void actionPerformed(ActionEvent e)
                            {
                                Pair<Integer, NetPlan> aux = callback.getCurrentNetPlan();
                                NetPlan netPlan = aux.getSecond();
                                NetPlan aux_netPlan = netPlan.copy();

                                try
                                {
                                    String[] attributeList = StringUtils.toArray(netPlan.getNetworkAttributes().keySet());
                                    if (attributeList.length == 0)
                                    {
                                        throw new Exception("No attribute to remove");
                                    }

                                    Object out = JOptionPane.showInputDialog(null, "Please, select an attribute to remove", "Remove attribute", JOptionPane.QUESTION_MESSAGE, null, attributeList, attributeList[0]);
                                    if (out == null) return;

                                    String attributeToRemove = out.toString();

                                    netPlan.removeNetworkAttribute(attributeToRemove);

                                    callback.updateNetPlanView();
                                }
                                catch (Exception ex)
                                {
                                    _netPlans.set(aux.getFirst(), aux_netPlan);
                                    ErrorHandling.showErrorDialog(ex.getMessage(), "Error removing attribute");
                                }
                            }
                        });

                        popup.add(removeAttribute);

                        JMenuItem removeAttributes = new JMenuItem("Remove all attributes");

                        removeAttributes.addActionListener(new ActionListener()
                        {

                            @Override
                            public void actionPerformed(ActionEvent e)
                            {
                                Pair<Integer, NetPlan> aux = callback.getCurrentNetPlan();
                                NetPlan aux_netPlan = aux.getSecond().copy();
                                try
                                {
                                    aux.getSecond().setNetworkAttributes(new HashMap<String, String>());
                                    callback.updateNetPlanView();
                                }
                                catch (Exception ex)
                                {
                                    _netPlans.set(aux.getFirst(), aux_netPlan);
                                    ErrorHandling.showErrorDialog("Error removing attributes");
                                    ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
                                }
                            }
                        });

                        popup.add(removeAttributes);

                        popup.show(e.getComponent(), e.getX(), e.getY());
                    }
                }
            };
            _netPlanTables[6].addMouseListener(networkTableAdapter);
        }

	scrollPane[6].setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Attributes"));
        
        for(ParamValueTable table : _networkSummaryTables)
            table.setAutoCreateRowSorter(true);

	JPanel networkInfo = new JPanel();
	networkInfo.setLayout(new MigLayout("insets 0 0 0 0", "[grow]"));
	networkInfo.add(new JLabel("Topology and link capacities"), "growx, wrap");
	networkInfo.add(new JScrollPane(_networkSummaryTables[0]), "growx, wrap");
	networkInfo.add(new JLabel("Traffic"), "growx, wrap");
	networkInfo.add(new JScrollPane(_networkSummaryTables[1]), "growx, wrap");
	networkInfo.add(new JLabel("Routing"), "growx, wrap");
	networkInfo.add(new JScrollPane(_networkSummaryTables[2]), "growx, wrap");
	networkInfo.add(new JLabel("Resilience information"), "growx, wrap");
	networkInfo.add(new JScrollPane(_networkSummaryTables[3]), "growx");
        
        _networkName.setEditable(isEditable);
        _networkDescription.setEditable(isEditable);
        _networkDescription.setFont(new JLabel().getFont());
	_networkDescription.setLineWrap(true);
	_networkDescription.setWrapStyleWord(true);
        
//	DefaultCaret caret = (DefaultCaret) _networkDescription.getCaret();
//	caret.setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
        
        JPanel networkPanel = new JPanel(new MigLayout("", "[][grow]", "[][][grow]"));
        networkPanel.add(new JLabel("Name"));
        networkPanel.add(_networkName, "grow, wrap");
        networkPanel.add(new JLabel("Description"), "aligny top");
        networkPanel.add(new JScrollPane(_networkDescription), "grow, wrap, height 100::");
        networkPanel.add(scrollPane[6], "grow, spanx 2");

	JSplitPane splitPaneTopology = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
	splitPaneTopology.setTopComponent(networkPanel);
	splitPaneTopology.setBottomComponent(new JScrollPane(networkInfo));
	splitPaneTopology.setResizeWeight(0.3);
	splitPaneTopology.addPropertyChangeListener(new ProportionalResizeJSplitPaneListener());
//	splitPaneTopology.setBorder(new LineBorder(contentPane.getBackground()));
	((JScrollPane) splitPaneTopology.getBottomComponent()).setBorder(BorderFactory.createEmptyBorder());

	_networkStatePane.addTab("Network", splitPaneTopology);
	_networkStatePane.addTab("Nodes", scrollPane[0]);
	_networkStatePane.addTab("Links", scrollPane[1]);
	_networkStatePane.addTab("Demands", scrollPane[2]);
	_networkStatePane.addTab("Routes", scrollPane[3]);
	_networkStatePane.addTab("Protection segments", scrollPane[4]);
	_networkStatePane.addTab("Shared-risk groups", scrollPane[5]);
    }
    
    private void initNetPlanPanel()
    {
	DefaultTableModel[] model = new DefaultTableModel[netPlanTables.length];

	model[0] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[0].length], netPlanTablesHeader[0])
	{
            private static final long serialVersionUID = 1L;

	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex)
	    {
		return (columnIndex > 0 && columnIndex < 4);
	    }

	    @Override
	    public void setValueAt(Object newValue, int row, int column)
	    {
		Object oldValue = getValueAt(row, column);

		// If value doesn't change, exit from function
		if (newValue.equals(oldValue)) return;

		Pair<Integer, NetPlan> aux = getCurrentNetPlan();
		NetPlan netPlan = aux.getSecond();
		NetPlan aux_netPlan = netPlan.copy();

		int nodeId = row;

		// Perform checks, if needed
		try
		{
		    switch (column)
		    {
			case 1:
			    netPlan.setNodeName(nodeId, newValue.toString());
			    break;

			case 2:
			    netPlan.setNodeXYPosition(nodeId, Double.parseDouble(newValue.toString()), netPlan.getNodeXYPosition(nodeId)[1]);
			    break;

			case 3:
			    netPlan.setNodeXYPosition(nodeId, netPlan.getNodeXYPosition(nodeId)[0], Double.parseDouble(newValue.toString()));
			    break;

			default:
			    return;
		    }

		    pan_topology.getCanvas().updateTopology(netPlan);
		    updateSelectBoxes();
		}
		catch (Throwable ex)
		{
		    netPlans.set(aux.getFirst(), aux_netPlan);
		    return;
		}

                // Set new value
		super.setValueAt(newValue, row, column);

                pan_topology.getCanvas().resetPickedState();
            }
	};

	model[1] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[1].length], netPlanTablesHeader[1])
	{
            private static final long serialVersionUID = 1L;

	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex)
	    {
		return columnIndex == 3 || columnIndex == 7;
	    }

	    @Override
	    public void setValueAt(Object newValue, int row, int column)
	    {
		Object oldValue = getValueAt(row, column);

		// If value doesn't change, exit from function
		if (newValue.equals(oldValue)) return;

		Pair<Integer, NetPlan> aux = getCurrentNetPlan();
		NetPlan netPlan = aux.getSecond();
		NetPlan aux_netPlan = netPlan.copy();

		// Perform checks, if needed
		try
		{
		    switch (column)
		    {
			case 3:
			    netPlan.setLinkCapacityInErlangs(row, Double.parseDouble(newValue.toString()));
			    break;

			case 7:
			    netPlan.setLinkLengthInKm(row, Double.parseDouble(newValue.toString()));
			    break;

			default:
			    return;
		    }

		    updateSelectBoxes();
		}
		catch (Throwable ex)
		{
		    netPlans.set(aux.getFirst(), aux_netPlan);
		    return;
		}

		// Set new value
		super.setValueAt(newValue, row, column);

                pan_topology.getCanvas().resetPickedState();
            }
	};

	model[2] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[2].length], netPlanTablesHeader[2])
	{
            private static final long serialVersionUID = 1L;

	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex)
	    {
		return columnIndex == 3;
	    }

	    @Override
	    public void setValueAt(Object newValue, int row, int column)
	    {
		Object oldValue = getValueAt(row, column);

		// If value doesn't change, exit from function
		if (newValue.equals(oldValue)) return;

		Pair<Integer, NetPlan> aux = getCurrentNetPlan();
		NetPlan netPlan = aux.getSecond();
		NetPlan aux_netPlan = netPlan.copy();

		// Perform checks, if needed
		try
		{
		    switch (column)
		    {
			case 3:
			    netPlan.setDemandOfferedTrafficInErlangs(row, Double.parseDouble(newValue.toString()));
			    break;

			default:
			    return;
		    }
                    
		    updateSelectBoxes();
		}
		catch (Throwable ex)
		{
		    netPlans.set(aux.getFirst(), aux_netPlan);
                    
		    ErrorHandling.showErrorDialog(ex.getMessage(), "Error changing offered traffic");
		    return;
		}

		// Set new value
		super.setValueAt(newValue, row, column);

                pan_topology.getCanvas().resetPickedState();
            }
	};

	model[3] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[3].length], netPlanTablesHeader[3])
	{
            private static final long serialVersionUID = 1L;

	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex)
	    {
		return columnIndex == 5;
	    }

	    @Override
	    public void setValueAt(Object newValue, int row, int column)
	    {
		Object oldValue = getValueAt(row, column);

		if (newValue.equals(oldValue)) return;

		Pair<Integer, NetPlan> aux = getCurrentNetPlan();
		NetPlan netPlan = aux.getSecond();
		NetPlan aux_netPlan = netPlan.copy();

		// Perform checks, if needed
		try
		{
		    switch (column)
		    {
			case 5:
			    netPlan.setRouteCarriedTrafficInErlangs(row, Double.parseDouble(newValue.toString()));
			    break;

			default:
			    return;
		    }

                    updateSelectBoxes();
		}
		catch (Throwable ex)
		{
		    netPlans.set(aux.getFirst(), aux_netPlan);

		    ErrorHandling.showErrorDialog(ex.getMessage(), "Error changing carried traffic");
		    return;
		}

		// Set new value
		super.setValueAt(newValue, row, column);

                pan_topology.getCanvas().resetPickedState();
            }
	};

	model[4] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[4].length], netPlanTablesHeader[4])
	{
            private static final long serialVersionUID = 1L;

	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex)
	    {
		return columnIndex == 3;
	    }

	    @Override
	    public void setValueAt(Object newValue, int row, int column)
	    {
		Object oldValue = getValueAt(row, column);

		if (newValue.equals(oldValue)) return;

		Pair<Integer, NetPlan> aux = getCurrentNetPlan();
		NetPlan netPlan = aux.getSecond();
		NetPlan aux_netPlan = netPlan.copy();

		// Perform checks, if needed
		try
		{
		    switch (column)
		    {
			case 3:
			    netPlan.setProtectionSegmentReservedBandwidthInErlangs(row, Double.parseDouble(newValue.toString()));
			    break;

			default:
			    return;
		    }

                    updateSelectBoxes();
		}
		catch (Throwable ex)
		{
		    netPlans.set(aux.getFirst(), aux_netPlan);

		    ErrorHandling.showErrorDialog(ex.getMessage(), "Error changing reserved traffic");
		    return;
		}

		// Set new value
		super.setValueAt(newValue, row, column);

                pan_topology.getCanvas().resetPickedState();
            }
	};

	model[5] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[5].length], netPlanTablesHeader[5])
	{
            private static final long serialVersionUID = 1L;

	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex)
	    {
		return columnIndex >= 1 && columnIndex <= 4;
	    }

	    @Override
	    public void setValueAt(Object newValue, int row, int column)
	    {
		Object oldValue = getValueAt(row, column);

		if (newValue.equals(oldValue)) return;

		Pair<Integer, NetPlan> aux = getCurrentNetPlan();
		NetPlan netPlan = aux.getSecond();
		NetPlan aux_netPlan = netPlan.copy();

		// Perform checks, if needed
		try
		{
		    switch (column)
		    {
			case 1:
			    netPlan.setSRGMeanTimeToFailInHours(row, Double.parseDouble(newValue.toString()));
			    break;
                            
			case 2:
			    netPlan.setSRGMeanTimeToRepairInHours(row, Double.parseDouble(newValue.toString()));
			    break;
                            
                        case 3:
                            int[] previousNodeIds = netPlan.getSRGNodes(row);
                            for(int nodeId : previousNodeIds) netPlan.removeNodeFromSRG(nodeId, row);

                            int[] nodeIds = StringUtils.toIntArray(StringUtils.split(newValue.toString(), ", "));
                            for(int nodeId : nodeIds) netPlan.addNodeToSRG(nodeId, row);
                            
                            Arrays.sort(nodeIds);
                            newValue = IntUtils.join(nodeIds, ", ");
                            
                            break;

                        case 4:
                            int[] previousLinkIds = netPlan.getSRGLinks(row);
                            for(int linkId : previousLinkIds) netPlan.removeLinkFromSRG(linkId, row);

                            int[] linkIds = StringUtils.toIntArray(StringUtils.split(newValue.toString(), ", "));
                            for(int linkId : linkIds) netPlan.addLinkToSRG(linkId, row);
                            
                            Arrays.sort(linkIds);
                            newValue = IntUtils.join(linkIds, ", ");
                            
                            break;

                        default:
			    return;
		    }

                    updateSelectBoxes();
		}
		catch (Throwable ex)
		{
		    netPlans.set(aux.getFirst(), aux_netPlan);

		    ErrorHandling.showErrorDialog(ex.getMessage(), "Error changing SRG state");
		    return;
		}

		// Set new value
		super.setValueAt(newValue, row, column);
                
                pan_topology.getCanvas().resetPickedState();
	    }
	};

        model[6] = new ClassAwareTableModel(new Object[1][netPlanTablesHeader[6].length], netPlanTablesHeader[6]);

	for (int itemId = 0; itemId < netPlanTables.length; itemId++)
        {
	    netPlanTables[itemId] = new AdvancedJTable(model[itemId]);

            ColumnHeaderToolTips tips = new ColumnHeaderToolTips();
            for (int c = 0; c < netPlanTables[itemId].getColumnCount(); c++)
            {
                  TableColumn col = netPlanTables[itemId].getColumnModel().getColumn(c);
                  tips.setToolTip(col, netPlanTablesHeaderTips[itemId][c]);
            }
            
            netPlanTables[itemId].getTableHeader().addMouseMotionListener(tips);        
        }

        decorators = new LinkedList<FixedColumnDecorator>();
                
        for(ParamValueTable table : networkSummaryTables)
            table.setAutoCreateRowSorter(true);
        
        networkName = new JTextField();
        networkDescription = new JTextArea();
        networkName.getDocument().addDocumentListener(new NetworkNameListener());
        networkDescription.getDocument().addDocumentListener(new NetworkDescriptionListener());

        initializeNetworkState(this, pan_topology, pan_editnetPlan, netPlans, netPlanTables, model, decorators, netPlanTablesHeader, networkName, networkDescription, networkSummaryTables, true);
    }

    class NetworkDescriptionListener implements DocumentListener
    {
        @Override
        public void insertUpdate(DocumentEvent e) { updateNetPlanDescription(); }

        @Override
        public void removeUpdate(DocumentEvent e) { updateNetPlanDescription(); }

        @Override
        public void changedUpdate(DocumentEvent e) { updateNetPlanDescription(); }
        
        private void updateNetPlanDescription()
        {
            String name = networkDescription.getText();
            NetPlan netPlan = getCurrentNetPlan().getSecond();
            netPlan.setNetworkDescription(name);
        }
    }

    class NetworkNameListener implements DocumentListener
    {
        @Override
        public void insertUpdate(DocumentEvent e) { updateNetPlanName(); }

        @Override
        public void removeUpdate(DocumentEvent e) { updateNetPlanName(); }

        @Override
        public void changedUpdate(DocumentEvent e) { updateNetPlanName(); }
        
        private void updateNetPlanName()
        {
            String name = networkName.getText();
            NetPlan netPlan = getCurrentNetPlan().getSecond();
            netPlan.setNetworkName(name);
            pan_topology.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Network topology: " + (name.isEmpty() ? "Untitled" : name)));
        }
    }

    private void initReportPanel()
    {
	final JPanel pnl_buttons = new JPanel(new MigLayout("", "[center, grow]", "[]"));

	reportsPane.setVisible(false);

	((JComponent) this).registerKeyboardAction(new ActionListener()
	{
	    @Override
	    public void actionPerformed(ActionEvent e)
	    {
		int tab = reportsPane.getSelectedIndex();
		if (tab == -1) return;

		reportsPane.remove(tab);
	    }
	}, KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.CTRL_DOWN_MASK), JComponent.WHEN_IN_FOCUSED_WINDOW);

	reportsPane.addContainerListener(new ContainerListener()
	{

	    @Override
	    public void componentAdded(ContainerEvent e)
	    {
		reportsPane.setVisible(true);
		pan_viewReports.setDividerLocation(0.5);
	    }

	    @Override
	    public void componentRemoved(ContainerEvent e)
	    {
		if (reportsPane.getTabCount() == 0) reportsPane.setVisible(false);
	    }
	});

	JButton btn_show = new JButton("Show"); btn_show.setToolTipText("Show the report");
	btn_show.addActionListener(new ActionListener()
	{

	    @Override
	    public void actionPerformed(ActionEvent e)
	    {
		reportController.execute();
	    }
	});

	reportsPane.addMouseListener(new MouseAdapter()
	{

	    @Override
	    public void mouseClicked(MouseEvent e)
	    {
		int tabNumber = reportsPane.getUI().tabForCoordinate(reportsPane, e.getX(), e.getY());

		if (tabNumber >= 0)
		{
		    Rectangle rect = ((TabIcon) reportsPane.getIconAt(tabNumber)).getBounds();
		    if (rect.contains(e.getX(), e.getY()))
		    {
			reportsPane.removeTabAt(tabNumber);
		    }
		}
	    }
	});

	pnl_buttons.add(btn_show);

        JPanel pane = new JPanel(new BorderLayout());
        pane.add(reportSelector, BorderLayout.CENTER);
        pane.add(pnl_buttons, BorderLayout.SOUTH);
	pan_viewReports.setTopComponent(pane);
        
	pan_viewReports.setBottomComponent(reportsPane);
	pan_viewReports.addPropertyChangeListener(new ProportionalResizeJSplitPaneListener());
	pan_viewReports.setResizeWeight(0.5);
    }

    @Override
    public void resetView()
    {
	pan_topology.getCanvas().resetPickedState();
	for (JTable table : netPlanTables) table.clearSelection();
    }
}